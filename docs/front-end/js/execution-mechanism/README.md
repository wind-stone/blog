# JavaScript 执行机制

PS: 该文章几乎所有的内容来自于[极客时间-浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)

JavaScript 会先编译再执行，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

- 函数只有在被调用的时候，才会被编译。

## 变量提升

变量提升（`hoisting`），是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值`undefined`。

在变量提升过程中，

- 若声明了两个同名的函数，则最终生效的是最后声明的函数。
- 若声明的变量和函数同名，那么在编译阶段，变量的声明会被忽略。

### 为什么要设计变量提升

ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。变量提升所带来的问题

## 执行上下文

当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。一般情况下，有这么三种情况会创建执行上下文：

- 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 当使用`eval`函数的时候，`eval`的代码也会被编译，并创建执行上下文。

执行上下文里包含变量环境和词法环境。变量环境主要维护编译阶段通过`var`声明的变量和函数声明。词法环境主要维护执行阶段块级作用域产生的变量和环境。

### 调用栈（执行上下文栈）

### 变量环境

### 词法环境

### 作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。

- **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- **函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

ES6 开始，增加了**块级作用域**。

#### 作用域链

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为`outer`。而`outer`这个执行上下文里也会指向它自己的`outer`执行上下文，如此便形成了作用域链。

#### 词法作用域

在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。

**词法作用域**就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

#### 闭包

```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了（且其执行上下文也已出栈了），但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是`foo`，那么这些变量的集合（这里是`test1`和`myName`）就称为`foo`函数的闭包。

## 疑问

### 块级作用域里声明函数

```js
debugger;
(function(){
    console.log('g:', g);
    if(true){
        console.log('hello world');
        function g(){ return true; }
    }
})();
```

执行以上代码会发现，`g`打印出来的值是`undefined`。这是为什么呢？

ECMAScript 里规定函数不能在块级作用域中声明。也就是说，下面这段代码执行会报错，但是各大浏览器都没有遵守这个标准。

```js
function foo(){
    if(true){
        console.log('hello world');
        function g(){ return true; }
    }
}
```

接下来到了 ES6 了，ES6 明确支持块级作用域，ES6 规定块级作用域内部声明的函数，和通过`let`声明变量的行为类似。

规定的是理想的，但是还要照顾实现，要是完全按照`let`的方式来修订，会影响到以前老的代码，所以为了向下兼容，各大浏览器基本是按照下面的方式来实现的：

```js
function foo(){
    if(true){
        console.log('hello world');
        var g = function(){return true;}
    }
}
```

这就解释了`g`打印出来的值为什么是`undefined`，不过还是不建议在块级作用域中定义函数，很多时候，简单的才是最好的。
