# 视觉格式化模型

[[toc]]

视觉格式化模型，`visual formatting model`。

翻译自 CSS 2.2 官方文档，[Visual formatting model](https://www.w3.org/TR/CSS22/visuren.html)

## 介绍

这一章和下一章描述了视觉格式化模型: 用户代理（比如浏览器）如何为视觉媒体（比如屏幕）处理文档树。

在视觉格式化模型里，文档树里的每一个元素会根据盒模型生成 0 或多个盒子`box`。这些盒子的布局由以下因素决定：

- 盒子的尺寸
  - `content-area`
  - `padding`
  - `border`
  - `margin`
- 盒子的类型
  - 行内盒(`inline box`)
  - 行内级盒（`inline-level box`）
  - 块盒（`block box`）
- 定位方案（`positioning scheme`）
  - 常规流
  - 浮动
  - 绝对定位
- 文档树里元素之间的关系
- 外部信息（比如视口尺寸、图片的固有尺寸等）

该章节和下一章节定义的属性，可以应用到流媒体（`continuous media`）和分页媒体（`paged media`）。但是，当应用到分页媒体时，`margin`相关的属性的意义就有所改变了，详情可见[page model](https://www.w3.org/TR/CSS22/page.html#page-margins)

视觉格式化模型没有明确格式化的各个方面（比如它没有指定一个`letter-spacing`算法），因此针对规格文档里没有涉及的格式化问题，用户代理可能表现不一致。

### 视口

流媒体的用户代理通常给用户提供一个视口（屏幕上的一个窗口或者其他可视区域），以让用户翻阅文档。当视口`resized`后，用户代理可能改变文档的布局，可见[初始包含块](https://www.w3.org/TR/CSS22/visudet.html#containing-block-details)

当视口小于文档渲染的画布区域时，用户代理应该提供一个滚动机制。每一张画布至少有一个视口，但是用户代理可能渲染到不止一张画布上（比如提供同一个文档的不同视图）。

### 包含块

在 CSS 2.2 里，许多盒子的位置和尺寸的计算，都会跟一个称为包含块（`containing blocks`）的矩形盒子的边界有关。通常，生成的盒子就像是包含了后代盒子的块。我们称为一个盒子为它的后代“建立”了包含块。“一个盒子的包含块”指的是这个盒子所位于的包含块，而不是这个盒子生成的包含块。

每一个盒子都会有一个跟包含块有关的位置，但并不局限于包含块，比如它可能会溢出`overflow`。

关于包含块尺寸的计算细节，将在下一章节描述。

## 控制盒的生成

接下来我们将描述在 CSS 2.2 里可能产生的盒子的类型。在视觉格式化模型里，盒子的类型会部分影响它的行为。以下描述的`display`属性，明确了盒子的类型。

某些`display`属性的值，将导致源文档里的元素生成一个主盒（`principal box`）以包含后代盒子和内容，同时其自身也是参与到定位方案中的盒子。有些元素除了主盒之外，可能还会生成额外的盒子，比如`list-item`元素。这些额外的盒子的放置位置与主盒有关。

### 块级元素和块盒

块级元素（`block-level elements`）—— 这些源文档里的元素视觉上呈现为块（比如段落`p`元素），也是生成块级主盒的元素。设置元素的`display`属性为以下值，将导致元素成为块级的。

- `block`
- `list-item`
- `table`

块级盒（`block-level boxes`）是参与块格式化上下文 BFC 的盒子。

（译者注: 块级盒是否就是块级元素以及`display`为`block`等值的元素生成的盒子？）

在 CSS 2.2 里，一个块级盒同时也是块容器盒（`block container box`），除非它是一个`table box`或是一个可替换元素的主盒。一个块容器盒要么仅包含块级盒，要么建立一个行内格式化上下文 IFC 并仅包含行内级盒。若元素的主盒是块容器盒，则该元素是块容器元素。`display`属性的以下取值，将使得一个非替换元素生成块容器盒。

- `block`
- `list-item`
- `inline-block`

不是所有的块容器盒都是块级盒: 非替换行内块（译者注: 比如`display: inline-block`的`span`元素）和非替换`table cell`都是块容器盒但不是块级盒。若块级盒同时也是块容器盒，则称为块盒（`block boxes`）。

这里有三个术语，块级盒（`block-level box`）、块容器盒（`block container box`）、块盒（`block box`），在语义清晰的时候都简称为块（`block`）。

#### 匿名块盒

在如下的文档里，（假设 DIV 和 P 都是`display: block`），DIV 既有行内内容也有块内容。为了更容易地定义格式化，我们假设在“Some text”周边有一个匿名的块盒。

```html
<DIV>
  Some text
  <P>More text
</DIV>
```

![图 1](./img/diagram-1.png)

图 1: 图里显示了三个盒子，其中一个是匿名的

关于匿名块盒详细的描述: 这个图说明了匿名块盒是如何存在于匿名内容周边的。这里有两个包含文本的矩形盒子，第一个是匿名的，它有一个浅灰色的背景，并包含了文本“Some text”。在它之下，是`p`元素的盒子，稍深灰色的背景，并包含了文本`More text`。这两个盒子都在`div`元素的盒子里面。

换句话说，如果一个块容器盒（比如上面 DIV 元素生成的盒子）里面有一个块级盒（比如上面的 P 元素生成的盒子），那么我们会强制让该块容器盒仅包含块级盒（译者注: 以添加匿名块盒的方式）。

当一个行内盒包含了一个处于常规流中的块级盒，这个行内盒（以及与它在同一行盒里的它的行内祖先盒子）将被这个块级盒（以及与它连续的兄弟块级盒，或者被“可折叠的空格”或“脱离了常规流的元素”分开的兄弟块级盒）折断，并将这个行内盒分离为两个盒子（即使两边都是空的），分别处于块级盒的两边。折断处之前和之后的行内盒都会被匿名块盒包裹住，并且原先的块级盒将成为这些匿名块盒的兄弟盒子。若是这个行内盒被相对定位所影响，任何因而产生的转变，也将影响到这个行内盒所包含的块级盒。

> 根据如上的规则，这个模型将应用到下面的示例里。
>
> ```css
> p    { display: inline }
> span { display: block }
> ```
>
> ```html
> <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
> <HEAD>
> <TITLE>Anonymous text interrupted by a block</TITLE>
> </HEAD>
> <BODY>
> <P>
> This is anonymous text before the SPAN.
> <SPAN>This is the content of SPAN.</SPAN>
> This is anonymous text after the SPAN.
> </P>
> </BODY>
> ```
>
> P 元素包含了一个匿名文本的块（C1），其后是一个块级元素，再其后是另一个匿名文本的块（C2）。最终生成的盒子将是:，一个块盒，代表 BODY 元素，其中包含了：
>
> - 一个包裹着 C1 的匿名块盒
> - SPAN 块盒
> - 另一个包裹着 C2 的匿名块盒

匿名块盒的属性将继承于封闭的非匿名盒子（比如上面小节标题“匿名块盒”下的示例里的 DIV 盒子）。非继承属性有它们的初始值。比如，匿名块盒的`font`属性将继承于 DIV，但是`margin`属性将为 0。

已设置在导致生成匿名块盒元素上的属性，仍将应用到匿名块盒以及元素的内容上。比如在上面的示例里，若是已为 P 元素设置了`border`，那么 C1 和 C2 周围也将会有`border`。（译者注：但不会应用到 SPAN 元素上）

![图 2](./img/diagram-2.png)

图 2: 在 P 元素上设置了`border: 1px solid red`，导致包裹 C1 和 C2 的匿名块盒都有`border`，但 SPAN 元素没有

一些用户代理已经以其他方式实现了行内包含块的边框，比如在匿名行盒内部包装一个嵌套的块，并在这些盒子周边绘制行内边框。由于 CSS1 和 CSS2 并没有定义这个行为，`CSS1-only`和`CSS2-only`的用户代理可能实现了这个可选的模型，并声称和 CSS 2.2 的这部分保持了一致。而在这个规则文档发布之后开发的用户代理则不是这样。

当遇到处理指向匿名块盒的百分比值时，匿名块盒将被忽略，而距离最近的非匿名祖先盒子将被使用。比如，若是上面 DIV 元素里的匿名块盒的子元素需要知道它的包含块的高度以处理子元素的百分比高度时，将会使用由 DIV 元素形成的包含块的高度，而不是匿名块盒的高度。

### 行内级元素和行内盒
