# 浏览器里的事件循环机制

## 消息队列

标准里定义了很多队列，但是浏览器只实现了常规消息队列和延迟消息队列，这两个队列里存放的都是宏任务。

延迟消息队列主要是放一些定时执行的任务，如 JavaScript 设置定时器的回调，还有浏览器内部的一些定时回调任务，这类任务需要等到指定时间间隔之后执行。

而常规的消息队列（简称为消息队列）中的任务只会按照顺序执行，执行完上个任务接着执行下个任务，不需要关系时间间隔。

::: warning 注意
这里的延迟消息队列并不是真正的数据结构上的队列，其本质是个 HashMap，等到主线程检查延迟消息队列时，会计算 HashMap 里的每个任务是否到期，若是到期则取出执行，执行完所有到期的任务后，才会进入到下一轮循环。
:::

### 消息队列里可能有哪些宏任务

- 当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中。
- 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
- 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
- 同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中
- 异步 XMLHttpRequest 请求回调

以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。

## 定时器的实现

如下以`setTimeout`举例，`setInterval`同理。

### setTimeout 的实现

当调用定时器如`setTimeout(fn, delay)`设置回调函数时，回调函数需要在指定的`delay`时间后执行。但是，消息队列中的任务是按序执行的，因而无法保证回调函数能在指定时间后执行，因此渲染进程不能将回调任务添加到消息队列里。

Chrome 里除了常规使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务，我们姑且先称其为延迟消息队列。因此当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟消息队列中。

当通过 JavaScript 调用`setTimeout(fn, delay)`设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数`fn`、当前发起时间、延迟执行时间，其模拟代码如下所示：

```c++
struct DelayTask{
  int64 id；
  CallBackFunction cbf;
  int start_time;
  int delay_time;
};
DelayTask timerTask;
timerTask.cbf = fn;
timerTask.start_time = getCurrentTime(); // 获取当前时间
timerTask.delay_time = delay;            // 设置延迟执行时间
```

创建好回调任务之后，再将该任务添加到延迟消息队列里。那么，事件循环系统是如何执行延迟消息队列里的任务的呢？

```c++
void ProcessTimerTask(){
  // 从 延迟消息队列 中取出已经到期的定时器任务
  // 依次执行这些任务
}

TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){
  for(;;){
    // 执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);

    // 执行延迟消息队列中的任务
    ProcessDelayTask()

    // 如果设置了退出标志，那么直接退出线程循环
    if(!keep_running)
        break;
  }
}
```

上段代码中，处理完消息队列中的单个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的回调任务（可能有多个），然后依次执行这些到期的任务。等到期的回调任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

需要注意的是，每一次事件循环，都会先从消息队列里取出一个宏任务执行，该宏任务执行完成后，主线程会去检查延迟消息队列里的所有宏任务，将已经到期的宏任务全部取出后一一执行，等到这些宏任务执行完毕后，再进入到下一次事件循环。此外，不管是消息队列里的宏任务还是延迟消息队列里的宏任务，其执行时都会创建其专属的微任务队列，等到该宏任务执行完毕后，再将其所属的微任务队列里的微任务一一执行。

### clearTimeout 的实现

调用定时器如`clearTimeout`之后，JavaScript 引擎会返回一个定时器的 ID。通常情况下，当一个定时器的回调任务还没有被执行时，可以调用`clearTimeout`函数并传入需要定时器的 ID 来取消回调任务的执行。其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从延迟消息队列中，通过 ID 查找到对应的回调任务，然后再将其从队列中删除就可以了。

### 使用 setTimeout 的一些注意事项

- 如果当前任务执行时间过久，会影响定时器任务的执行

若是从`task_queue`取出的`task`执行时间过久，尽管定时器设置的延时时间在`task`执行完成之前就已经达到，但是必须等到`task`执行完成之后，主线程才会去检查延迟消息队列。因此，不管是`setTimeout`还是`setInterval`，其最终延迟执行的时间，都会大于等于设置的`delay`。

- 如果`setTimeout`存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒

`setTimeout`嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。这是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。

- 未激活的页面`setTimeout`执行最小间隔是 1000 毫秒

如果标签页不是当前的激活标签页，或者页面被切换到后台，那么页面里的定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

- 延时执行时间`delay`有最大值，超过最大值后会被设置为 0

Chrome、Safari、Firefox 都是以 32 位来存储延时值的，32 位最大只能存放的数字是 2147483647 毫秒（2<sup>31</sup>-1，因为有一位是符号位）。也就是说，如果`setTimeout`设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

- `setTimeout`设置的回调函数中的`this`指向全局`window`（严格模式下为`undefined`）

## 异步 XMLHttpRequest 请求回调

- 创建 XMLHttpRequest 对象`xhr`，注册回调、配置请求信息后，调用`xhr.send`发起网络请求。
- 渲染进程将请求发送给网络进程，由网络进程负责资源的下载；网络进程接收到数据之后，会通过 IPC（进程间通信）通知渲染进程。
- 渲染进程接收到信息之后，会将`xhr`的回调函数封装成任务并添加到消息队列中。
- 主线程进行事件循环执行到该任务时，会根据相关的状态来调用对应的回调函数。
  - 网络请求出错，执行`xhr.onerror`
  - 网络请求超时，执行`xhr.ontimeout`
  - 网络请求正常，执行`xhr.onreadystatechange`
